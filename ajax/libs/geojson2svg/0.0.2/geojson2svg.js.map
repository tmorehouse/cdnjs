{
  "version": 3,
  "file": "generated.js",
  "sources": [
    "/usr/local/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/home/ubuntu/projects/geojson2svg/node_modules/deep-extend/index.js",
    "/home/ubuntu/projects/geojson2svg/node_modules/multigeojson/index.js",
    "/home/ubuntu/projects/geojson2svg/src/converter.js",
    "/home/ubuntu/projects/geojson2svg/src/instance.js",
    "/home/ubuntu/projects/geojson2svg/src/main.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/*!\n * Node.JS module \"Deep Extend\"\n * @description Recursive object extending.\n * @author Viacheslav Lotsmanov (unclechu) <lotsmanov89@gmail.com>\n * @license MIT\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2013 Viacheslav Lotsmanov\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Extening object that entered in first argument.\n * Returns extended object or false if have no target object or incorrect type.\n * If you wish to clone object, simply use that:\n *  deepExtend({}, yourObj_1, [yourObj_N]) - first arg is new empty object\n */\nvar deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {\n    if (arguments.length < 1 || typeof arguments[0] !== 'object') {\n        return false;\n    }\n\n    if (arguments.length < 2) return arguments[0];\n\n    var target = arguments[0];\n\n    // convert arguments to array and cut off target object\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var key, val, src, clone;\n\n    args.forEach(function (obj) {\n        if (typeof obj !== 'object') return;\n\n        for (key in obj) {\n            if ( ! (key in obj)) continue;\n\n            src = target[key];\n            val = obj[key];\n\n            if (val === target) continue;\n\n            if (typeof val !== 'object' || val === null) {\n                target[key] = val;\n                continue;\n            }\n\n            if (typeof src !== 'object' || src === null) {\n                clone = (Array.isArray(val)) ? [] : {};\n                target[key] = deepExtend(clone, val);\n                continue;\n            }\n\n            if (Array.isArray(val)) {\n                clone = (Array.isArray(src)) ? src : [];\n            } else {\n                clone = (!Array.isArray(src)) ? src : {};\n            }\n\n            target[key] = deepExtend(clone, val);\n        }\n    });\n\n    return target;\n}\n",
    "//index.js \n(function() { \n\tvar singles = ['Point', 'LineString', 'Polygon'];\n\tvar multies = ['MultiPoint', 'MultiLineString', 'MultiPolygon'];\n\tfunction explode(g) {\n\t  if( multies.indexOf(g.type) > -1) {\n\t    return g.coordinates.map(function(part) {\n\t      var single = {};\n\t      single.type = g.type.replace('Multi','');\n\t      single.coordinates = part;\n        if(g.crs) single.crs = g.crs;\n\t      return single;\n\t    });  \n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tfunction implode(gs) {\n\t  var sameType = gs.every(function(g) { \n\t    return singles.indexOf(g.type) > -1;\n\t  })\n    var crs = gs[0].crs || 0;\n    var sameCrs = gs.every(function(g) {\n      var gcrs = g.crs || 0;\n      return gcrs == crs;\n    });\n\t  if(sameType && sameCrs) {\n\t    var multi = {};\n\t    multi.type = 'Multi' + gs[0].type;\n\t    multi.coordinates = [];\n      if(crs != 0) multi.crs = crs;\n\t    gs.forEach(function(g) {\n\t      multi.coordinates.push(g.coordinates);\n\t    });\n\t    return multi;\n\t  } else {\n\t    return false;\n\t  }\n\t};\n\tvar multigeojson = {\n\t  explode: explode,\n\t  implode: implode\n\t};\n\tif(typeof module !== 'undefined' && module.exports) {\n\t  module.exports = multigeojson;\n\t} else if(window) {\n\t  window.multigeojson = multigeojson;\n\t}\n})();\n",
    "//converter.js\nvar multi = require('multigeojson');\nfunction getCoordString(coords,res,origin) {\n  //origin - svg image origin \n  var coordStr = coords.map(function(coord) {\n    return (coord[0] - origin.x)/res + ',' + (origin.y - coord[1])/res;\n  });\n  return coordStr.join(' ');\n}\nfunction addAttributes(ele,attributes) {\n  var part = ele.split('/>')[0];\n  for(var key in attributes) {\n    if(attributes[key]) {\n      part += ' ' + key + '=\"' + attributes[key] + '\"';\n    }\n  }\n  return part + ' />';\n}\n\nfunction point(geom,res,origin,opt) {\n  var r = opt && opt.r ? opt.r : 1;\n  var path = 'M' + getCoordString([geom.coordinates],res,origin)\n    +' m'+ -r+ ',0'+ ' a'+r+','+ r + ' 0 1,1 '+ 2*r + ','+0\n    +' a'+r+','+ r + ' 0 1,1 '+ -2*r + ','+0;\n  return [path];\n}\nfunction multiPoint(geom,res,origin,opt) {\n  var explode = opt && opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function(single) {\n    return point(single,res,origin,opt)[0];\n  });\n  if(!explode) return [paths.join(' ')]\n  return paths;\n\n}\nfunction lineString(geom,res,origin,otp) {\n  var coords = getCoordString(geom.coordinates,res,origin);\n  var path = 'M'+ coords;  \n  return [path];\n}\nfunction multiLineString(geom,res,origin,opt) {\n  var explode = opt && opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function(single) {\n    return lineString(single,res,origin,opt)[0];\n  });\n  if(!explode) return [paths.join(' ')]\n  return paths;\n}\nfunction polygon(geom,res,origin,opt) {\n  var mainStr,holes,holeStr;\n  mainStr = getCoordString(geom.coordinates[0],res,origin);\n  if (geom.coordinates.length > 1) {\n    holes = geom.coordinates.slice(1,geom.coordinates.length);\n  }\n  var path = 'M'+ mainStr;\n  if(holes) {\n    for(var i=0;i<holes.length; i++) {\n      path += ' M' +  getCoordString(holes[i],res,origin);\n    }\n  }\n  path += 'Z';\n  return [path];\n}\nfunction multiPolygon(geom,res,origin,opt) {\n  var explode = opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function(single) {\n    return polygon(single,res,origin,opt)[0];\n  });\n  if(!explode) return [paths.join(' ').replace(/Z/g,'') + 'Z'];\n  return paths;\n}\nmodule.exports = {\n  Point: point,\n  MultiPoint: multiPoint,\n  LineString: lineString,\n  MultiLineString: multiLineString,\n  Polygon: polygon,\n  MultiPolygon: multiPolygon\n};\n",
    "var extend = require('deep-extend'),\n\tconverter = require('./converter.js');\n\n//g2svg as geojson2svg (shorthand)\nvar g2svg = function(viewportSize,opt) {\n  if(!viewportSize) return;\n  this.viewportSize = viewportSize;\n  var opt = opt || {};\n  this.mapExtent = opt.mapExtent \n    || {'left':-180,'bottom':-90,'right':180,'top':90}; \n  this.res = this.calResolution(this.mapExtent,this.viewportSize);\n};\ng2svg.prototype.calResolution = function(extent,size) {\n  var xres = (extent.right - extent.left)/size.width;\n  var yres = (extent.top - extent.bottom)/size.height;\n  return Math.max(xres,yres);\n};\ng2svg.prototype.convert = function(geojson,options)  {\n  var options = options || {};\n  var multiGeometries = ['MultiPoint','MultiLineString','MultiPolygon'];\n  var geometries = ['Point', 'LineString', 'Polygon'];\n  var svgElements = [];\n  if (geojson.type == 'FeatureCollection') {\n    for(var i=0; i< geojson.features.length; i++) {\n      svgElements = svgElements.concat(\n        this.convertFeature(geojson.features[i],options));\n    }\n  } else if (geojson.type == 'Feature') {\n    svgElements = this.convertFeature(geojson,options);\n  } else if (geojson.type == 'GeomtryCollection') {\n    for(var i=0; i< geojson.geometries.length; i++) {\n      svgElements = svgElements.concat(\n        this.convertGeometry(geojson.geometries[i],options));\n    }\n  } else if (converter[geojson.type]) {\n    svgElements = this.convertGeometry(geojson,options);\n  } else {\n    return;\n  }\n  if(options.callback) options.callback.call(this,svgElements);\n  return svgElements;\n};\ng2svg.prototype.convertFeature = function(feature,options) {\n  if(!feature.geometry) return;\n  var opt = {};\n  extend(opt,options);\n  opt.attributes = opt.attributes || {};\n  opt.attributes.id = opt.attributes.id || feature.id || null;\n  return this.convertGeometry(feature.geometry,opt);\n};\ng2svg.prototype.convertGeometry = function(geom,opt) {\n  if(converter[geom.type]) {\n    var opt = opt || {};\n    //var explode = opt.hasOwnProperty('explode') ? opt.explode : false;\n    var paths = converter[geom.type].call(this,geom,\n      this.res,\n      {x:this.mapExtent.left,y:this.mapExtent.top},\n      opt\n    );\n    var svgJsons,svgEles;\n    if(opt.output && opt.output.toLowerCase() == 'svg') {\n      svgJsons = paths.map(function(path) {\n        return pathToSvgJson(path,geom.type,opt.attributes,opt);\n      });\n      svgEles = svgJsons.map(function(json) {\n        return jsonToSvgElement(json,geom.type);\n      });\n      return svgEles;\n    }\n    return paths;\n  } else {\n    return;\n  }\n};\nvar pathToSvgJson = function(path,type,attributes,opt) {\n  var svg = {};\n  var forcePath = opt && opt.hasOwnProperty('forcePath') ? opt.forcePath\n     : true;\n  if((type == 'Point' || type == 'MultiPoint') && !forcePath) {\n    svg['cx'] = path.split(',')[0];\n    svg['cy'] = path.split(',')[1];\n    svg['r'] = opt && opt.r ? opt.r : '1';\n  } else {\n    svg = {d: path};\n    if(type == 'Polygon' || type == 'MultiPolygon') {\n      svg['fill-rule'] == 'evenodd'; \n    } \n  }\n  for (var key in attributes) {\n    svg[key]= attributes[key];\n  }\n  return svg;\n};\nvar jsonToSvgElement = function(json,type,opt) {\n  var forcePath = opt && opt.hasOwnProperty('forcePath') ? opt.forcePath\n     : true;\n  var ele ='<path';\n  if((type == 'Point' || type == 'MultiPoint') && !forcePath) {\n    ele = '<circle';\n  }\n  for(var key in json) {\n    ele += ' ' + key +'=\"' + json[key] + '\"';\n  }\n  ele += '/>';\n  return ele;\n};\n\nmodule.exports = g2svg;\n",
    "var extend = require('deep-extend');\nvar g2svg = require('./instance.js');\nvar geojson2svg = function(viewportSize,options) {\n  if(!viewportSize) return;\n  return new g2svg(viewportSize,options);\n};\n\nif(typeof module !== 'undefined' && module.exports) {\n  module.exports = geojson2svg;\n} \nif(window !== 'undefined') {\n  window.geojson2svg = geojson2svg;\n}\n"
  ],
  "sourceRoot": ""
}