{"version":3,"file":"ceb-feature-template.min.js","sources":["../src/ceb-feature-template.js"],"names":["g","factory","exports","module","define","amd","cebFeatureTemplate","this","feature","el","__cebTemplateScope","findContentNode","oldCebContentId","getAttribute","querySelector","apply","tpl","isHandleLightDOM","isNodeReferences","lightChildren","refrencedNodes","template","result","nodesRegEx","exec","property","newAtt","counter","replace","push","attribute","oldContentNode","childNodes","length","removeChild","newCebContentId","setAttribute","innerHTML","newContentNode","forEach","child","appendChild","entry","setup","struct","builder","options","search","contentRegEx","wrap","next","arguments"],"mappings":";;;;;;;;CAoBC,SAAUA,EAAGC,GACV,YAGuB,iBAAZC,SACPC,OAAOD,QAAUD,IACQ,kBAAXG,SAAyBA,OAAOC,IAC9CD,OAAO,0BAA4BH,GAEnCD,EAAEM,mBAAqBL,KAG7BM,KAAM,WACJ,YAKA,SAASC,GAAQC,GAIb,MAHKA,GAAGC,qBACJD,EAAGC,uBAEAD,EAAGC,mBAed,QAASC,GAAgBF,GACrB,GAAIG,GAAkBH,EAAGI,aAAa,qBACtC,OAAID,GACOD,EAAgBF,EAAGK,cAAc,IAAMF,EAAkB,MAE7DH,EAIX,QAASM,GAAMC,EAAKP,EAAIQ,EAAkBC,GACtC,GAAIC,MACAC,KACAC,EAAWL,CAEf,IAAIE,EAGA,IADA,GAAII,GAC4C,QAAxCA,EAASC,EAAWC,KAAKH,KAAqB,CAClD,GAAII,GAAWH,EAAO,GAElBI,EAAS,OAAUC,KAAa,MAEpCN,GAAWA,EAASO,QAAQ,WAAY,IAAMF,GAE9CN,EAAeS,MACXC,UAAWJ,EACXD,SAAUA,IAKtB,GAAIR,EAAkB,CASlB,IAHA,GAAIc,GAAiBpB,EAAgBF,GAG9BsB,EAAeC,WAAWC,OAAS,GACtCd,EAAcU,KAAKE,EAAeG,YAAYH,EAAeC,WAAW,IAK5E,IAAIG,GAAkB,OAAUR,KAAa,UAG7CN,GAAWA,EAASO,QAAQ,eAAgB,IAAMO,GAGlD1B,EAAG2B,aAAa,qBAAsBD,GAM1C,GAFA1B,EAAG4B,UAAYhB,EAEXJ,EAAkB,CAElB,GAAIqB,GAAiB3B,EAAgBF,EACrCU,GAAcoB,QAAQ,SAAUC,GAC5BF,EAAeG,YAAYD,KAK/BtB,GAEAE,EAAemB,QAAQ,SAAUG,GAC7BlC,EAAQC,GAAIiC,EAAMjB,UAAYhB,EAAGK,cAAc,IAAM4B,EAAMZ,UAAY,OASnF,QAASa,GAAMC,EAAQC,EAASC,GAC5B,GAAI9B,GAAM8B,EAAQzB,UAAY,GAC1BJ,EAAgD,KAA7BD,EAAI+B,OAAOC,GAC9B9B,EAA8C,KAA3BF,EAAI+B,OAAOxB,EAGlCsB,GAAQI,KAAK,kBAAmB,SAAUC,EAAMzC,GAC5CM,EAAMC,EAAKP,EAAIQ,EAAkBC,GACjCgC,EAAKC,aAhGb,GAAIxB,GAAU,EAGVJ,EAAa,uBAGbyB,EAAe,gBA+FnB,OAFAxC,GAAQmC,MAAQA,EAETnC","sourcesContent":["// # ceb-feature-template.js\n\n// Works on ever-green browsers and IE9/IE10.\n// However the template feature doesn't work with [document-register-element](https://github.com/WebReflection/document-register-element) on IE9/IE10.\n\n// ## Light DOM\n//\n// The template can contains a node having the attribute `ceb-content`.\n// The marked node is intend to host the light DOM of the current element at the end of the templating process.\n//\n// If the template doesn't contain this node, the light DOM will be lost.\n//\n// ## DOM nodes references\n//\n// The template can contains nodes having the attribute `ceb-ref`.\n// The marked nodes will be available at the end of the templating process from the feature function (`feature(el)`).\n//\n// That means, if a node has the attribute `ceb-ref=\"header\"`.\n// It will be available via `feature(el).header`.\n\n(function (g, factory) {\n    'use strict';\n \n    /* istanbul ignore next */\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define('ceb-feature-template', [], factory);\n    } else {\n        g.cebFeatureTemplate = factory();\n    }\n\n}(this, function () {\n    'use strict';\n\n    // ## feature function\n\n    // The template feature's function returns the nodes' reference of the template.\n    function feature(el) {\n        if (!el.__cebTemplateScope) {\n            el.__cebTemplateScope = {};\n        }\n        return el.__cebTemplateScope;\n    }\n\n    // ## Templating stuff\n\n    // The counter is used to generate unique DOM's id.\n    var counter = 0;\n\n    // Regex to detect the *ceb-ref* attributes\n    var nodesRegEx = /ceb\\-ref=\\W*(\\w*)/igm;\n\n    // Regex to detect the *ceb-content* attribute\n    var contentRegEx = /ceb\\-content/im;\n\n    // Find recursively the content's node of the current element.\n    function findContentNode(el) {\n        var oldCebContentId = el.getAttribute('ceb-old-content-id');\n        if (oldCebContentId) {\n            return findContentNode(el.querySelector('[' + oldCebContentId + ']'));\n        }\n        return el;\n    }\n\n    // Apply a template to an element.\n    function apply(tpl, el, isHandleLightDOM, isNodeReferences) {\n        var lightChildren = [],\n            refrencedNodes = [],\n            template = tpl;\n\n        if (isNodeReferences) {\n            // Update the template to detect the DOM nodes references.\n            var result;\n            while ((result = nodesRegEx.exec(template)) !== null) {\n                var property = result[1];\n                // build an id of the reference\n                var newAtt = 'ceb-' + (counter++) + '-ref';\n                // replace the original attribute name by the idenitifer\n                template = template.replace(' ceb-ref', ' ' + newAtt);\n                // push the entry\n                refrencedNodes.push({\n                    attribute: newAtt,\n                    property: property\n                });\n            }\n        }\n\n        if (isHandleLightDOM) {\n            // Get the current content node having the light DOM nodes,\n            // When the node is freshly created, the content node is the element.\n            // When the node has been created by clonning, the content node is not anymore the element,\n            // but a sub content node linked to one of its descents.\n\n            var oldContentNode = findContentNode(el);\n\n            // Remove the light DOM to keep it.\n            while (oldContentNode.childNodes.length > 0) {\n                lightChildren.push(oldContentNode.removeChild(oldContentNode.childNodes[0]));\n            }\n            // lightChildren = Array.prototype.slice.call(oldContentNode.childNodes);\n\n            // Generate the new content's id value.\n            var newCebContentId = 'ceb-' + (counter++) + '-content';\n\n            // Replace the original attribute name by the id.\n            template = template.replace(' ceb-content', ' ' + newCebContentId);\n\n            // Keep a value of the content's id value if the node is cloned.\n            el.setAttribute('ceb-old-content-id', newCebContentId);\n        }\n\n        // Transform the template string into an alive DOM nodes.\n        el.innerHTML = template;\n\n        if (isHandleLightDOM) {\n            // Get the content node to add him the in pending light DOM.\n            var newContentNode = findContentNode(el);\n            lightChildren.forEach(function (child) {\n                newContentNode.appendChild(child);\n                // newContentNode.appendChild(child);\n            });\n        }\n\n        if (isNodeReferences) {\n            // Get the reference nodes and attach them to the element templating scope.\n            refrencedNodes.forEach(function (entry) {\n                feature(el)[entry.property] = el.querySelector('[' + entry.attribute + ']');\n            });\n        }\n\n    }\n\n    // ## Setup function\n\n    // The templeting process is done before the call of the `createdCallback` method defined in the structure.\n    function setup(struct, builder, options) {\n        var tpl = options.template || '';\n        var isHandleLightDOM = tpl.search(contentRegEx) !== -1;\n        var isNodeReferences = tpl.search(nodesRegEx) !== -1;\n        // Register a wrapper to the createdCallback callback in order to\n        // apply the template before the original call.\n        builder.wrap('createdCallback', function (next, el) {\n            apply(tpl, el, isHandleLightDOM, isNodeReferences);\n            next(arguments);\n        });\n    }\n    feature.setup = setup;\n\n    return feature;\n}));\n"]}