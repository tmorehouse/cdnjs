{"version":3,"file":"ceb-feature-frp.min.js","sources":["../src/ceb-feature-frp.js"],"names":["g","factory","exports","module","define","amd","cebFeatureFrp","this","feature","el","__cebFrpScope","emptyFn","disposable","disposableFactory","handlers","handlersFactory","anotherDisposable","propertyObserverFactory","Error","propertyObservableInterceptor","disposeDisposable","setup","struct","builder","options","observerProperties","Object","keys","properties","map","propName","property","filter","entry","observable","forEach","valueFactory","attName","set","intercept","wrap","next","arguments","disposables","undefined"],"mappings":";;;;;;;;CAAC,SAAUA,EAAGC,GACV,YAKuB,iBAAZC,SACPC,OAAOD,QAAUD,IACQ,kBAAXG,SAAyBA,OAAOC,IAC9CD,OAAO,qBAAuBH,GAE9BD,EAAEM,cAAgBL,KAGxBM,KAAM,WACJ,YAKA,SAASC,GAAQC,GAIb,MAHKA,GAAGC,gBACJD,EAAGC,kBAEAD,EAAGC,cAgDd,QAASC,KACL,MAAO,cAwEX,MApHAH,GAAQI,WAAa,SAAUC,GAW3B,MAVAA,GAAkBC,SAAW,SAAUC,GACnC,MAAO,UAAUN,GACb,GAAIG,GAAaC,EAAkBJ,GAC/BO,EAAoBD,EAAgBN,EAAIG,EAC5C,OAAII,GACOA,EAEJJ,IAGRC,GAQXL,EAAQS,wBAA0B,WAC9B,KAAM,IAAIC,OAAM,qBASpBV,EAAQW,8BAAgC,WACpC,KAAM,IAAID,OAAM,qBAMpBV,EAAQY,kBAAoB,WACxB,KAAM,IAAIF,OAAM,qBAUpBV,EAAQa,MAAQ,SAAUC,EAAQC,EAASC,GACvC,GAAIC,MAGAR,EAA0BO,EAAQP,yBAA2BT,EAAQS,wBACrEE,EAAgCK,EAAQL,+BAAiCX,EAAQW,8BACjFC,EAAoBI,EAAQJ,mBAAqBZ,EAAQY,iBAG7DM,QAAOC,KAAKL,EAAOM,YAAYC,IAAI,SAAUC,GACzC,OACIA,SAAUA,EACVC,SAAUT,EAAOM,WAAWE,MAEjCE,OAAO,SAAUC,GAChB,MAAOA,GAAMF,SAASG,aACvBC,QAAQ,SAAUF,GAEjBR,EAAmBQ,EAAMH,SAAW,aAChCM,aAAcnB,GAGbgB,EAAMF,SAASM,SAAYJ,EAAMF,SAASO,MAC3CL,EAAMF,SAASO,IAAM3B,KAGzBY,EAAQgB,UAAUN,EAAMH,SAAUX,KAItCI,EAAQK,WAAWH,GAEnBF,EAAQiB,KAAK,kBAAmB,SAAUC,EAAMhC,GAC5CgC,EAAKC,WAELlC,EAAQC,GAAIkC,aAAenB,EAAQmB,iBAAmBd,IAAI,SAAUhB,GAChE,MAAOA,GAAkBJ,OAIjCc,EAAQiB,KAAK,mBAAoB,SAAUC,EAAMhC,GAE7CiB,OAAOC,KAAKF,GAAoBU,QAAQ,SAAUL,GACzCrB,EAAGqB,KACJrB,EAAGqB,GAAYb,EAAwBR,MAI1CD,EAAQC,GAAIkC,cACbnC,EAAQC,GAAIkC,aAAenB,EAAQmB,iBAAmBd,IAAI,SAAUhB,GAChE,MAAOA,GAAkBJ,MAGjCgC,EAAKC,aAGTnB,EAAQiB,KAAK,mBAAoB,SAAUC,EAAMhC,GAC7CgC,EAAKC,WAELhB,OAAOC,KAAKF,GAAoBU,QAAQ,SAAUL,GAC9CV,EAAkBX,EAAGqB,IACrBrB,EAAGqB,GAAYc,SAGnBpC,EAAQC,GAAIkC,YAAYR,QAAQf,GAChCZ,EAAQC,GAAIkC,YAAc,QAI3BnC","sourcesContent":["(function (g, factory) {\n    'use strict';\n\n    // Export the **ceb-feature-frp** function according the detected loader.\n\n    /* istanbul ignore next */\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define('ceb-feature-frp', [], factory);\n    } else {\n        g.cebFeatureFrp = factory();\n    }\n\n}(this, function () {\n    'use strict';\n\n    // ## Feature function\n\n    // The FRP feature's function returns nothing for public API.\n    function feature(el) {\n        if (!el.__cebFrpScope) {\n            el.__cebFrpScope = {};\n        }\n        return el.__cebFrpScope;\n    }\n\n    // ## Observer factory\n\n    feature.disposable = function (disposableFactory) {\n        disposableFactory.handlers = function (handlersFactory) {\n            return function (el) {\n                var disposable = disposableFactory(el);\n                var anotherDisposable = handlersFactory(el, disposable);\n                if (anotherDisposable) {\n                    return anotherDisposable;\n                }\n                return disposable;\n            };\n        };\n        return disposableFactory;\n    };\n\n    // ## Default functions\n\n    // This function must returns the instance to the property observer.\n    // > @param el (HTMLElement) the current element\n    /* istanbul ignore next */\n    feature.propertyObserverFactory = function defaultPropertyObserverFactory() {\n        throw new Error('not implemented!');\n    };\n\n    // When the observed property is set, the value must be pushed into the stream.\n    // > @param next (function) will call the next stacked callback\n    // > @param el (HTMLElement) the current element\n    // > @param propName (string) the name of the observed property\n    // > @param value (*) the value of the previous stacked callback\n    /* istanbul ignore next */\n    feature.propertyObservableInterceptor = function defaultPropertyObservableInterceptor(next, el, propName, value) {\n        throw new Error('not implemented!');\n    };\n\n    // This function must clear the observers instances given as argument.\n    // > @param observer (object) the observer to kick\n    /* istanbul ignore next */\n    feature.disposeDisposable = function defaultDisposeDisposable(observer) {\n        throw new Error('not implemented!');\n    };\n\n    // ## Setup\n\n    // Return a new empty function.\n    function emptyFn() {\n        return function () {};\n    }\n\n    feature.setup = function (struct, builder, options) {\n        var observerProperties = {};\n\n        // Resolve the locked functions.\n        var propertyObserverFactory = options.propertyObserverFactory || feature.propertyObserverFactory;\n        var propertyObservableInterceptor = options.propertyObservableInterceptor || feature.propertyObservableInterceptor;\n        var disposeDisposable = options.disposeDisposable || feature.disposeDisposable;\n\n        // Iterate over the structure's properties in order to detect the observable properties.\n        Object.keys(struct.properties).map(function (propName) {\n            return {\n                propName: propName,\n                property: struct.properties[propName]\n            };\n        }).filter(function (entry) {\n            return entry.property.observable;\n        }).forEach(function (entry) {\n            // Create the observer property of the observed property.\n            observerProperties[entry.propName + 'Observer'] = {\n                valueFactory: propertyObserverFactory\n            };\n            // Set is required for interception\n            if (!entry.property.attName && !entry.property.set) {\n                entry.property.set = emptyFn();\n            }\n            // Register the interceptor which will sync the observer with the property's value.\n            builder.intercept(entry.propName, propertyObservableInterceptor);\n        });\n\n        // Add the new properties to the structure.\n        builder.properties(observerProperties);\n\n        builder.wrap('createdCallback', function (next, el) {\n            next(arguments);\n            // When the element is created the observers must created.\n            feature(el).disposables = (options.disposables || []).map(function (disposableFactory) {\n                return disposableFactory(el);\n            });\n        });\n\n        builder.wrap('attachedCallback', function (next, el) {\n            // When the element is attached the observers of properties must be available ...\n            Object.keys(observerProperties).forEach(function (propName) {\n                if (!el[propName]) {\n                    el[propName] = propertyObserverFactory(el);\n                }\n            });\n            // ... and the others observers too.\n            if (!feature(el).disposables) {\n                feature(el).disposables = (options.disposables || []).map(function (disposableFactory) {\n                    return disposableFactory(el);\n                });\n            }\n            next(arguments);\n        });\n\n        builder.wrap('detachedCallback', function (next, el) {\n            next(arguments);\n            // When the element is detached the observers of properties must be disposed ...\n            Object.keys(observerProperties).forEach(function (propName) {\n                disposeDisposable(el[propName]);\n                el[propName] = undefined;\n            });\n            // ... and the others observers too.\n            feature(el).disposables.forEach(disposeDisposable);\n            feature(el).disposables = null;\n        });\n    };\n\n    return feature;\n}));\n"]}