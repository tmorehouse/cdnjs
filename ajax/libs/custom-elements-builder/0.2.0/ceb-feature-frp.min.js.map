{"version":3,"file":"ceb-feature-frp.min.js","sources":["../src/ceb-feature-frp.js"],"names":["g","factory","exports","module","define","amd","cebFeatureFrp","this","feature","el","__cebFrpScope","emptyFn","disposable","disposableFactory","handlers","handlersFactory","anotherDisposable","defaultPropertyObserverFactory","window","Rx","Subject","defaultPropertyObservableInterceptor","next","propName","value","onNext","defaultDisposeDisposable","observer","dispose","setup","struct","builder","options","observerProperties","propertyObserverFactory","propertyObservableInterceptor","disposeDisposable","Object","keys","properties","map","property","filter","entry","observable","forEach","valueFactory","attName","set","intercept","wrap","arguments","disposables","undefined"],"mappings":";;;;;;;;CAAC,SAAUA,EAAGC,GACV,YAGuB,iBAAZC,SACPC,OAAOD,QAAUD,IACQ,kBAAXG,SAAyBA,OAAOC,IAC9CD,OAAO,qBAAuBH,GAE9BD,EAAEM,cAAgBL,KAGxBM,KAAM,WACJ,YAKA,SAASC,GAAQC,GAIb,MAHKA,GAAGC,gBACJD,EAAGC,kBAEAD,EAAGC,cA8Cd,QAASC,KACL,MAAO,cAwEX,MAlHAH,GAAQI,WAAa,SAAUC,GAW3B,MAVAA,GAAkBC,SAAW,SAAUC,GACnC,MAAO,UAAUN,GACb,GAAIG,GAAaC,EAAkBJ,GAC/BO,EAAoBD,EAAgBN,EAAIG,EAC5C,OAAII,GACOA,EAEJJ,IAGRC,GAOXL,EAAQS,+BAAiC,WACrC,MAAO,IAAIC,QAAOC,GAAGC,SAQzBZ,EAAQa,qCAAuC,SAA8CC,EAAMb,EAAIc,EAAUC,GAC7GF,EAAKE,GACLf,EAAGc,EAAW,YAAYE,OAAOD,IAKrChB,EAAQkB,yBAA2B,SAAkCC,GACjEA,EAASC,WAUbpB,EAAQqB,MAAQ,SAAUC,EAAQC,EAASC,GACvC,GAAIC,MAGAC,EAA0BF,EAAQE,yBAA2B1B,EAAQS,+BACrEkB,EAAgCH,EAAQG,+BAAiC3B,EAAQa,qCACjFe,EAAoBJ,EAAQI,mBAAqB5B,EAAQkB,wBAG7DW,QAAOC,KAAKR,EAAOS,YAAYC,IAAI,SAAUjB,GACzC,OACIA,SAAUA,EACVkB,SAAUX,EAAOS,WAAWhB,MAEjCmB,OAAO,SAAUC,GAChB,MAAOA,GAAMF,SAASG,aACvBC,QAAQ,SAAUF,GAEjBV,EAAmBU,EAAMpB,SAAW,aAChCuB,aAAcZ,GAGbS,EAAMI,SAAYJ,EAAMF,SAASO,MAClCL,EAAMF,SAASO,IAAMrC,KAGzBoB,EAAQkB,UAAUN,EAAMpB,SAAUY,KAItCJ,EAAQQ,WAAWN,GAEnBF,EAAQmB,KAAK,kBAAmB,SAAU5B,EAAMb,GAC5Ca,EAAK6B,WAEL3C,EAAQC,GAAI2C,aAAepB,EAAQoB,iBAAmBZ,IAAI,SAAU3B,GAChE,MAAOA,GAAkBJ,OAIjCsB,EAAQmB,KAAK,mBAAoB,SAAU5B,EAAMb,GAE7C4B,OAAOC,KAAKL,GAAoBY,QAAQ,SAAUtB,GACzCd,EAAGc,KACJd,EAAGc,GAAYW,EAAwBzB,MAI1CD,EAAQC,GAAI2C,cACb5C,EAAQC,GAAI2C,aAAepB,EAAQoB,iBAAmBZ,IAAI,SAAU3B,GAChE,MAAOA,GAAkBJ,MAGjCa,EAAK6B,aAGTpB,EAAQmB,KAAK,mBAAoB,SAAU5B,EAAMb,GAC7Ca,EAAK6B,WAELd,OAAOC,KAAKL,GAAoBY,QAAQ,SAAUtB,GAC9Ca,EAAkB3B,EAAGc,IACrBd,EAAGc,GAAY8B,SAGnB7C,EAAQC,GAAI2C,YAAYP,QAAQT,GAChC5B,EAAQC,GAAI2C,YAAc,QAI3B5C","sourcesContent":["(function (g, factory) {\n    'use strict';\n\n    /* istanbul ignore next */\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define('ceb-feature-frp', [], factory);\n    } else {\n        g.cebFeatureFrp = factory();\n    }\n\n}(this, function () {\n    'use strict';\n\n    // ## Feature function\n\n    // The FRP feature's function returns nothing for public API.\n    function feature(el) {\n        if (!el.__cebFrpScope) {\n            el.__cebFrpScope = {};\n        }\n        return el.__cebFrpScope;\n    }\n\n    // ## Observer factory\n\n    feature.disposable = function (disposableFactory) {\n        disposableFactory.handlers = function (handlersFactory) {\n            return function (el) {\n                var disposable = disposableFactory(el);\n                var anotherDisposable = handlersFactory(el, disposable);\n                if (anotherDisposable) {\n                    return anotherDisposable;\n                }\n                return disposable;\n            };\n        };\n        return disposableFactory;\n    };\n\n    // ## Default functions\n\n    // This function must returns the instance to the property observer.\n    // > @param el (HTMLElement) the current element\n    feature.defaultPropertyObserverFactory = function defaultPropertyObserverFactory() {\n        return new window.Rx.Subject();\n    };\n\n    // When the observed property is set, the value must be pushed into the stream.\n    // > @param next (function) will call the next stacked callback\n    // > @param el (HTMLElement) the current element\n    // > @param propName (string) the name of the observed property\n    // > @param value (*) the value of the previous stacked callback\n    feature.defaultPropertyObservableInterceptor = function defaultPropertyObservableInterceptor(next, el, propName, value) {\n        next(value);\n        el[propName + 'Observer'].onNext(value);\n    };\n\n    // This function must clear the observers instances given as argument.\n    // > @param observer (object) the observer to kick\n    feature.defaultDisposeDisposable = function defaultDisposeDisposable(observer) {\n        observer.dispose();\n    };\n\n    // ## Setup\n\n    // Return a new empty function.\n    function emptyFn() {\n        return function () {};\n    }\n\n    feature.setup = function (struct, builder, options) {\n        var observerProperties = {};\n\n        // Resolve the locked functions.\n        var propertyObserverFactory = options.propertyObserverFactory || feature.defaultPropertyObserverFactory;\n        var propertyObservableInterceptor = options.propertyObservableInterceptor || feature.defaultPropertyObservableInterceptor;\n        var disposeDisposable = options.disposeDisposable || feature.defaultDisposeDisposable;\n\n        // Iterate over the structure's properties in order to detect the observable properties.\n        Object.keys(struct.properties).map(function (propName) {\n            return {\n                propName: propName,\n                property: struct.properties[propName]\n            };\n        }).filter(function (entry) {\n            return entry.property.observable;\n        }).forEach(function (entry) {\n            // Create the observer property of the observed property.\n            observerProperties[entry.propName + 'Observer'] = {\n                valueFactory: propertyObserverFactory\n            };\n            // Set is required for interception\n            if (!entry.attName && !entry.property.set) {\n                entry.property.set = emptyFn();\n            }\n            // Register the interceptor which will sync the observer with the property's value.\n            builder.intercept(entry.propName, propertyObservableInterceptor);\n        });\n\n        // Add the new properties to the structure.\n        builder.properties(observerProperties);\n\n        builder.wrap('createdCallback', function (next, el) {\n            next(arguments);\n            // When the element is created the observers must created.\n            feature(el).disposables = (options.disposables || []).map(function (disposableFactory) {\n                return disposableFactory(el);\n            });\n        });\n\n        builder.wrap('attachedCallback', function (next, el) {\n            // When the element is attached the observers of properties must be available ...\n            Object.keys(observerProperties).forEach(function (propName) {\n                if (!el[propName]) {\n                    el[propName] = propertyObserverFactory(el);\n                }\n            });\n            // ... and the others observers too.\n            if (!feature(el).disposables) {\n                feature(el).disposables = (options.disposables || []).map(function (disposableFactory) {\n                    return disposableFactory(el);\n                });\n            }\n            next(arguments);\n        });\n\n        builder.wrap('detachedCallback', function (next, el) {\n            next(arguments);\n            // When the element is detached the observers of properties must be disposed ...\n            Object.keys(observerProperties).forEach(function (propName) {\n                disposeDisposable(el[propName]);\n                el[propName] = undefined;\n            });\n            // ... and the others observers too.\n            feature(el).disposables.forEach(disposeDisposable);\n            feature(el).disposables = null;\n        });\n    };\n\n    return feature;\n}));\n"]}