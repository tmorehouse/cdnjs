{"version":3,"file":"ceb-feature-template.min.js","sources":["../src/ceb-feature-template.js"],"names":["g","factory","exports","module","define","amd","cebFeatureTemplate","this","feature","el","__cebTemplateScope","apply","tpl","isHandleLightDOM","isNodeReferences","oldCebContentId","newCebContentId","lightChildren","refrencedNodes","template","result","nodesRegEx","exec","property","newAtt","counter","replace","push","attribute","getAttribute","setAttribute","lightDomNode","querySelector","childNodes","length","removeChild","cloneNode","innerHTML","applyLigthDOM","forEach","entry","setup","struct","builder","options","search","contentRegEx","methods","setTimeout","contentNode","child","appendChild","wrap","next","arguments"],"mappings":";;;;;;;;CAiBC,SAASA,EAAGC,GACT,YAGuB,iBAAZC,SACPC,OAAOD,QAAUD,IACQ,kBAAXG,SAAyBA,OAAOC,IAC9CD,OAAO,0BAA4BH,GAEnCD,EAAEM,mBAAqBL,KAG7BM,KAAM,WACJ,YAKA,SAASC,GAAQC,GAIb,MAHKA,GAAGC,qBACJD,EAAGC,uBAEAD,EAAGC,mBAed,QAASC,GAAMC,EAAKH,EAAII,EAAkBC,GACtC,GAEIC,GACAC,EAHAC,KACAC,KAGAC,EAAWP,CAEf,IAAIE,EAGA,IADA,GAAIM,GAC4C,QAAxCA,EAASC,EAAWC,KAAKH,KAAqB,CAClD,GAAII,GAAWH,EAAO,GAElBI,EAAS,OAAUC,KAAa,MAEpCN,GAAWA,EAASO,QAAQ,WAAY,IAAMF,GAE9CN,EAAeS,MACXC,UAAWJ,EACXD,SAAUA,IAKtB,GAAIV,EAAkB,CAElBE,EAAkBN,EAAGoB,aAAa,sBAElCb,EAAkB,OAAUS,KAAa,WAEzCN,EAAWA,EAASO,QAAQ,eAAgB,IAAMV,GAElDP,EAAGqB,aAAa,qBAAsBd,EAOtC,KAHA,GAAIe,GAAgBhB,GAAmBN,EAAGuB,cAAc,IAAMjB,EAAkB,MAASN,EAGlFsB,EAAaE,WAAWC,OAAS,GAMpCjB,EAAcU,KAAKI,EAAaI,YAAYJ,EAAaE,WAAW,IAAIG,WAAU,IAK1F3B,EAAG4B,UAAYlB,EAGfV,EAAG6B,cAAcrB,GAEbH,GAEAI,EAAeqB,QAAQ,SAASC,GAC5BhC,EAAQC,GAAI+B,EAAMjB,UAAYd,EAAGuB,cAAc,IAAMQ,EAAMZ,UAAY,OASnF,QAASa,GAAMC,EAAQC,EAASC,GAC5B,GAAIhC,GAAMgC,EAAQzB,UAAY,GAC1BN,EAAgD,KAA7BD,EAAIiC,OAAOC,GAC9BhC,EAA8C,KAA3BF,EAAIiC,OAAOxB,EAElCsB,GAAQI,SACJT,cAAe,SAAS7B,EAAIQ,GACxB+B,WAAW,WACP,GAAIC,GAAcxC,EAAGuB,cAAc,IAAMvB,EAAGoB,aAAa,sBAAwB,IAC7EoB,KACyC,kBAA9BA,GAAYX,cACnBW,EAAYX,cAAcrB,GAE1BA,EAAcsB,QAAQ,SAASW,GAC3BD,EAAYE,YAAYD,OAIrC,MAKXP,EAAQS,KAAK,kBAAmB,SAASC,EAAM5C,GAC3CE,EAAMC,EAAKH,EAAII,EAAkBC,GACjCuC,EAAKC,aArGb,GAAI7B,GAAU,EAGVJ,EAAa,uBAGbyB,EAAe,gBAoGnB,OAFAtC,GAAQiC,MAAQA,EAETjC","sourcesContent":["// # ceb-feature-template.js\n\n// ## Light DOM\n//\n// The template can contains a node having the attribute `ceb-content`.\n// The marked node is intend to host the light DOM of the current element at the end of the templating process.\n//\n// If the template doesn't contain this node, the light DOM will be lost.\n//\n// ## DOM nodes references\n//\n// The template can contains nodes having the attribute `ceb-ref`.\n// The marked nodes will be available at the end of the templating process from the feature function (`feature(el)`).\n//\n// That means, if a node has the attribute `ceb-ref=\"header\"`.\n// It will be available via `feature(el).header`.\n\n(function(g, factory) {\n    'use strict';\n\n    /* istanbul ignore next */\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define('ceb-feature-template', [], factory);\n    } else {\n        g.cebFeatureTemplate = factory();\n    }\n\n}(this, function() {\n    'use strict';\n\n    // ## feature function\n\n    // The template feature's function returns the nodes' reference of the template.\n    function feature(el) {\n        if (!el.__cebTemplateScope) {\n            el.__cebTemplateScope = {};\n        }\n        return el.__cebTemplateScope;\n    }\n\n    // ## Templating stuff\n\n    // The counter is used to generate unique DOM's id.\n    var counter = 0;\n\n    // Regex to detect the *ceb-ref* attributes\n    var nodesRegEx = /ceb\\-ref=\\W*(\\w*)/igm;\n\n    // Regex to detect the *ceb-content* attribute\n    var contentRegEx = /ceb\\-content/im;\n\n    // Apply a template to an element.\n    function apply(tpl, el, isHandleLightDOM, isNodeReferences) {\n        var lightChildren = [],\n            refrencedNodes = [],\n            oldCebContentId,\n            newCebContentId,\n            template = tpl;\n\n        if (isNodeReferences) {\n            // Update the template to detect the DOM nodes references.\n            var result;\n            while ((result = nodesRegEx.exec(template)) !== null) {\n                var property = result[1];\n                // build an id of the reference\n                var newAtt = 'ceb-' + (counter++) + '-ref';\n                // replace the original attribute name by the idenitifer\n                template = template.replace(' ceb-ref', ' ' + newAtt);\n                // push the entry\n                refrencedNodes.push({\n                    attribute: newAtt,\n                    property: property\n                });\n            }\n        }\n\n        if (isHandleLightDOM) {\n            // When a node is cloned the light DOM of the cloned has to be retrived.\n            oldCebContentId = el.getAttribute('ceb-old-content-id');\n            // Generate the new content's id value.\n            newCebContentId = 'ceb-' + (counter++) + '-content';\n            // Replace the original attribute name by the id.\n            template = template.replace(' ceb-content', ' ' + newCebContentId);\n            // Keep a value of the content's id value if the node is cloned.\n            el.setAttribute('ceb-old-content-id', newCebContentId);\n            // Get the current root of light DOM nodes,\n            // if the node has been cloned the root is the element binding the old content id\n            // else it's the current element.\n            var lightDomNode = (oldCebContentId && el.querySelector('[' + oldCebContentId + ']')) || el;\n            // Iterate over the light DOM nodes in order to removed them from the DOM.\n            // They will re-added into the DOM when the content node of the elementn will be ready.\n            while (lightDomNode.childNodes.length > 0) {\n                // The following line works only with webcomponent.js\n                // lightChildren.push(lightDomNode.removeChild(lightDomNode.childNodes[0]));\n\n                // The following line works with both webcomponent.js and document-register-element.\n                // But each node have to be cloned :(\n                lightChildren.push(lightDomNode.removeChild(lightDomNode.childNodes[0]).cloneNode(true));\n            }\n        }\n\n        // Transform the template string into alive DOM nodes.\n        el.innerHTML = template;\n\n        // Add the light DOM nodes removed above into the new content node.\n        el.applyLigthDOM(lightChildren);\n\n        if (isNodeReferences) {\n            // Get the reference nodes and attach them to the element templating scope.\n            refrencedNodes.forEach(function(entry) {\n                feature(el)[entry.property] = el.querySelector('[' + entry.attribute + ']');\n            });\n        }\n\n    }\n\n    // ## Setup function\n\n    // The templeting process is done before the call of the `createdCallback` method defined in the structure.\n    function setup(struct, builder, options) {\n        var tpl = options.template || '';\n        var isHandleLightDOM = tpl.search(contentRegEx) !== -1;\n        var isNodeReferences = tpl.search(nodesRegEx) !== -1;\n        // Register a method to handle the light DOM nodes\n        builder.methods({\n            applyLigthDOM: function(el, lightChildren) {\n                setTimeout(function() {\n                    var contentNode = el.querySelector('[' + el.getAttribute('ceb-old-content-id') + ']');\n                    if (contentNode) {\n                        if (typeof contentNode.applyLigthDOM === 'function') {\n                            contentNode.applyLigthDOM(lightChildren);\n                        } else {\n                            lightChildren.forEach(function(child) {\n                                contentNode.appendChild(child);\n                            });\n                        }\n                    }\n                }, 0);\n            }\n        });\n        // Register a wrapper to the createdCallback callback in order to\n        // apply the template before the original call.\n        builder.wrap('createdCallback', function(next, el) {\n            apply(tpl, el, isHandleLightDOM, isNodeReferences);\n            next(arguments);\n        });\n    }\n    feature.setup = setup;\n\n    return feature;\n}));\n"]}